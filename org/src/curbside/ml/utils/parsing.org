#+PROPERTY: header-args:clojure :tangle ../../../../../src/curbside/ml/utils/parsing.clj :mkdirp yes :noweb yes :padline yes :results silent :comments link
#+OPTIONS: toc:2

#+TITLE: Parsing Utilities

* Table of Contents                                             :toc:noexport:
- [[#introduction][Introduction]]
  - [[#namespace-definition][Namespace definition]]
- [[#value-parsing][Value parsing]]
- [[#handling-doublenan][Handling Double/NaN]]
- [[#tests][Tests]]
  - [[#namespace-definition-1][Namespace definition]]
  - [[#parsing][Parsing]]
  - [[#nan-nil-tests][=nan->nil= tests]]

* Introduction

This namespace contains utilities used to parse data.

** Namespace definition

#+BEGIN_SRC clojure
(ns curbside.ml.utils.parsing
  (:require
   [clojure.string :as str]))
#+END_SRC

* Value parsing

#+BEGIN_SRC clojure
(defn parse-double
  "Parse a string into a double. If the string is empty return nil. If it is a
  double, return it. If it is an integer, type cast it into a double and return
  it."
  [s]
  (cond
    (and (string? s) (empty? s))
    nil

    (float? s)
    s

    (integer? s)
    (double s)

    (and (string? s) (= "true" (str/lower-case s)))
    1.0

    (and (string? s) (= "false" (str/lower-case s)))
    0.0

    (string? s)
    (Double/parseDouble s)))

(defn parse-float
  "Parse a string into a float. If the string is empty return nil. If it is a
  double, return it. If it is an integer, type cast it into a float and return
  it."
  [s]
  (cond
    (and (string? s) (empty? s))
    nil

    (float? s)
    s

    (integer? s)
    (float s)

    (and (string? s) (= "true" (str/lower-case s)))
    (float 1.0)

    (and (string? s) (= "false" (str/lower-case s)))
    (float 0.0)

    (string? s)
    (Float/parseFloat s)))

(def double-regex #"[-+]?[\d]+\.?[\d]*(?:[eE][-+]?[\d]+)?")
(def int-regex #"[-+]?[\d]+")

(defn parse-or-identity
  "Tries to parse either a long, a double or a boolean from `s`. If `s` does not contain a
  number, returns `s`."
  [s]
  (cond
    (empty? s)
    nil

    (re-matches double-regex s)
    (Double/parseDouble s)

    (re-matches int-regex s)
    (Long/parseLong s)

    (or (= "Infinity" s) (= "+Infinity" s)) ;; Regex not used here for speed
    Double/POSITIVE_INFINITY

    (= "-Infinity" s)
    Double/NEGATIVE_INFINITY

    (= "NaN" s)
    Double/NaN

    (= "false" s)
    false

    (= "true" s)
    true

    :else s))
#+END_SRC

* Handling Double/NaN

When doing interop with Weka, some of the functions may return =Double/NaN= as a value which may cause issues when serializing a =map= into =JSON=. To handle this case, we create a =nan->nil= that will convert a =Double/NaN= to a =nil=. At the same time we will mute any possible exceptions and return =nil= as well. This function is to be used when constructing a =map= that could be converted into =JSON=.

#+BEGIN_SRC clojure
(defmacro nan->nil
  "Evaluate the `body` and if the result of the evaluation is `Double/NaN` than
  `nil` is returned or if an exception is raised, otherwise the result is."
  [body]
  `(try
     (let [r# ~body]
       (when-not (and (double? r#)
                      (Double/isNaN r#)) r#))
     (catch Exception e#)))
#+END_SRC

* Tests
** Namespace definition

#+NAME: test namespace
#+BEGIN_SRC clojure :tangle ../../../../../test/curbside/ml/utils/parsing_test.clj
(ns curbside.ml.utils.parsing-test
  (:require
   [clojure.test :refer [deftest is testing]]
   [clojure.test.check.clojure-test :refer [defspec]]
   [clojure.test.check.properties :as prop]
   [clojure.spec.alpha :as s]
   [clojure.spec.gen.alpha :as gen]
   [curbside.ml.utils.parsing :as parsing]))
#+END_SRC

** Parsing

#+BEGIN_SRC clojure :tangle ../../../../../test/curbside/ml/utils/parsing_test.clj
(deftest test-parse-or-identity
  (testing "parsing integer values"
    (is (== 1 (parsing/parse-or-identity "1")))
    (is (== -1 (parsing/parse-or-identity "-1")))
    (is (== 123456 (parsing/parse-or-identity "+123456"))))

  (testing "parsing floating point values"
    (is (== 1.123 (parsing/parse-or-identity "1.123")))
    (is (== -20.12 (parsing/parse-or-identity "-20.12")))
    (is (== -150.0 (parsing/parse-or-identity "-1.5e2")))
    (is (== 0.02 (parsing/parse-or-identity "2.0e-2")))
    (is (== 500.0 (parsing/parse-or-identity "5e2")))
    (is (== Double/POSITIVE_INFINITY (parsing/parse-or-identity "+Infinity")))
    (is (== Double/POSITIVE_INFINITY (parsing/parse-or-identity "Infinity")))
    (is (== Double/NEGATIVE_INFINITY (parsing/parse-or-identity "-Infinity")))
    (is (Double/isNaN (parsing/parse-or-identity "NaN"))))

  (testing "parsing booleans"
    (is (true? (parsing/parse-or-identity "true")))
    (is (false? (parsing/parse-or-identity "false"))))

  (testing "parsing string as-is"
    (letfn [(is-identity [s]
              (is (= s (parsing/parse-or-identity s))))]
      (is-identity "3.0f")
      (is-identity "this is a string")
      (is-identity "35 string starting with a number")
      (is-identity "2018-11-27T00:00:00.000Z"))))

(defspec parse-or-identity--generated-float
  200
  (prop/for-all [n (s/gen double?)]
    (try
      (let [parsed (parsing/parse-or-identity (str n))]
        (or (and (Double/isNaN n) (Double/isNaN parsed))
            (== n parsed)))
      (catch Throwable _t false))))

(defspec parse-or-identity--generated-int
  200
  (prop/for-all [n (s/gen int?)]
    (try
      (== n (parsing/parse-or-identity (str n)))
      (catch Throwable _t false))))
#+END_SRC

** =nan->nil= tests

#+BEGIN_SRC clojure :tangle ../../../../../test/curbside/ml/utils/parsing_test.clj
(deftest test-nan-to-nil
  (testing "Test the nan->nil macro"
    (is (nil? (parsing/nan->nil ((fn [] Double/NaN)))))
    (is (nil? (parsing/nan->nil ((fn [] (throw (Exception. "Exception.")))))))
    (is (= (parsing/nan->nil ((fn  [] "test"))) "test"))))
#+END_SRC
