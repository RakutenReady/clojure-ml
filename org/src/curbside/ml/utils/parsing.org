#+PROPERTY: header-args:clojure :tangle ../../../../../src/curbside/ml/utils/parsing.clj :mkdirp yes :noweb yes :padline yes :results silent :comments link
#+OPTIONS: toc:2

#+TITLE: Parsing Utilities

* Table of Contents                                             :toc:noexport:
- [[#introduction][Introduction]]
  - [[#namespace-definition][Namespace definition]]
- [[#value-parsing][Value parsing]]
- [[#handling-doublenan][Handling Double/NaN]]
- [[#tests][Tests]]
  - [[#namespace-definition-1][Namespace definition]]
  - [[#nan-nil-tests][nan->nil tests]]

* Introduction

This namespace contains utilities used to parse data.

** Namespace definition

#+BEGIN_SRC clojure
(ns curbside.ml.utils.parsing
  (:require
   [clojure.string :as str]))
#+END_SRC

* Value parsing

#+BEGIN_SRC clojure
(defn parse-double
  "Parse a string into a double. If the string is empty return nil. If it is a
  double, return it. If it is an integer, type cast it into a double and return
  it. Else, return 0.0"
  [s]
  (cond
    (and (string? s) (empty? s))
    nil

    (float? s)
    s

    (integer? s)
    (double s)

    (and (string? s) (= "true" (str/lower-case s)))
    1.0

    (and (string? s) (= "false" (str/lower-case s)))
    0.0

    (string? s)
    (Double/parseDouble s)

    :else 0.0))

(defn parse-float
  "Parse a string into a float. If the string is empty return nil. If it is a
  double, return it. If it is an integer, type cast it into a float and return
  it. Else, return 0.0"
  [s]
  (cond
    (and (string? s) (empty? s))
    nil

    (float? s)
    s

    (integer? s)
    (float s)

    (and (string? s) (= "true" (str/lower-case s)))
    (float 1.0)

    (and (string? s) (= "false" (str/lower-case s)))
    (float 0.0)

    (string? s)
    (Float/parseFloat s)

    :else (float 0.0)))
#+END_SRC

* Handling Double/NaN

When doing interop with Weka, some of the functions may return =Double/NaN= as a value which may cause issues when serializing a =map= into =JSON=. To handle this case, we create a =nan->nil= that will convert a =Double/NaN= to a =nil=. At the same time we will mute any possible exceptions and return =nil= as well. This function is to be used when constructing a =map= that could be converted into =JSON=.

#+BEGIN_SRC clojure
(defmacro nan->nil
  "Evaluate the `body` and if the result of the evaluation is `Double/NaN` than
  `nil` is returned or if an exception is raised, otherwise the result is."
  [body]
  `(try
     (let [r# ~body]
       (when-not (and (double? r#)
                      (Double/isNaN r#)) r#))
     (catch Exception e#)))
#+END_SRC

* Tests
** Namespace definition

#+NAME: test namespace
#+BEGIN_SRC clojure :tangle ../../../../../test/curbside/ml/utils/parsing_test.clj
(ns curbside.ml.utils.parsing-test
  (:require
   [clojure.test :refer [deftest is testing]]
   [curbside.ml.utils.parsing :as parsing]))
#+END_SRC

** nan->nil tests

#+BEGIN_SRC clojure :tangle ../../../../../test/curbside/ml/utils/parsing_test.clj
(deftest test-nan-to-nil
  (testing "Test the nan->nil macro"
    (is (nil? (parsing/nan->nil ((fn [] Double/NaN)))))
    (is (nil? (parsing/nan->nil ((fn [] (throw (Exception. "Exception.")))))))
    (is (= (parsing/nan->nil ((fn  [] "test"))) "test"))))
#+END_SRC
