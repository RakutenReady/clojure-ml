#+PROPERTY: header-args:clojure :tangle ../../../../src/curbside/ml/models.clj :mkdirp yes :noweb yes :padline yes :results silent :comments link
#+OPTIONS: toc:2

#+TITLE: ML Algorithms Interface

* Table of Contents                                            :toc:noexport:
- [[#namespace-definition][Namespace definition]]
- [[#supported-algorithms][Supported algorithms]]
- [[#multimethods][Multimethods]]
  - [[#xgboost][XGBoost]]
  - [[#decision-trees][Decision trees]]
  - [[#svm][SVM]]
  - [[#linear-svm][Linear SVM]]
- [[#inference][Inference]]
- [[#evaluation][Evaluation]]
- [[#hyperparameters-optimization][Hyperparameters optimization]]

* Namespace definition

#+BEGIN_SRC clojure
(ns curbside.ml.models
  (:refer-clojure :exclude [load])
  (:require
   [clojure.data.csv :as csv]
   [clojure.java.io :as io]
   [clojure.math.combinatorics :as combinatorics]
   [clojure.spec.alpha :as s]
   [com.climate.claypoole :as cp]
   [curbside.ml.metrics :as metrics]
   [curbside.ml.models.xgboost :as xgboost]
   [curbside.ml.models.decision-trees :as decision-trees]
   [curbside.ml.models.linear-svm :as linear-svm]
   [curbside.ml.models.svm :as svm]
   [curbside.ml.utils.parsing :as parsing]
   [curbside.ml.utils.spec :as spec]
   [curbside.ml.training-sets.scaling :as scaling]
   [curbside.ml.training-sets.conversion :as conversion])
  (:import
   (java.io File)
   (java.util ArrayList)
   (weka.classifiers.evaluation NominalPrediction)))
#+END_SRC

* Supported algorithms

This library currently supports the following algorithms:

#+BEGIN_SRC clojure
(s/def ::algorithm #{:lsvm :svm :c4.5 :random-forest :m5p :xgboost})

(s/def ::predictor-type #{:regression :classification})
#+END_SRC

* Multimethods

All models implement a few common functions:

1. =save= to persist a trained model to disk.
2. =load= to load a trained model from disk.
3. =train= to train the model on a given problem.
4. =predict= to make a prediction
5. =dispose= to free allocated memory, if applicable

We will define multimethods for all of these operations. These multimethods will switch based on a keyword specifying the algorithm to use. Using a keyword allows us to easily specify the algorithm in the pipeline configs.

#+BEGIN_SRC clojure
(defmulti save
  (fn [algorithm model filepath]
    algorithm))

(defmulti load
  (fn [algorithm filepath]
    algorithm))

(defmulti load-from-bytes
  (fn [algorithm bytes]
    algorithm))

(defmulti train
  (fn [algorithm predictor-type training-set-path hyperparameters]
    algorithm))

(defmulti predict
  "Not meant to be called directly. Use =infer= instead."
  (fn [algorithm predictor-type model selected-features hyperparameters feature-vector]
    algorithm))

(defmulti dispose
  (fn [algorithm model]
    algorithm))

(defmethod dispose :default
  [_ _]
  nil)
#+END_SRC

** XGBoost

#+BEGIN_SRC clojure
(defmethod save :xgboost
  [_ model filepath]
  (xgboost/save model filepath))

(defmethod load :xgboost
  [_ filepath]
  (xgboost/load filepath))

(defmethod load-from-bytes :xgboost
  [_ bytes]
  (xgboost/load-from-bytes bytes))

(defmethod train :xgboost
  [_ _predictor-type training-set-path params]
  (xgboost/train training-set-path params))

(defmethod predict :xgboost
  [_ _predictor-type model _seleted-features hyperparameters feature-vector]
  (xgboost/predict model hyperparameters feature-vector))

(defmethod dispose :xgboost
  [_ model]
  (xgboost/dispose model))
#+END_SRC

** Decision trees

#+BEGIN_SRC clojure
(defmethod save :c4.5
  [_algorithm model filepath]
  (decision-trees/save model filepath))

(defmethod save :m5p
  [_algorithm model filepath]
  (decision-trees/save model filepath))

(defmethod save :random-forest
  [_algorithm model filepath]
  (decision-trees/save model filepath))

(defmethod load :c4.5
  [_ file]
  (decision-trees/load file))

(defmethod load :m5p
  [_ file]
  (decision-trees/load file))

(defmethod load :random-forest
  [_ file]
  (decision-trees/load file))

(defmethod load-from-bytes :c4.5
  [bytes]
  (decision-trees/load-from-bytes bytes))

(defmethod load-from-bytes :m5p
  [bytes]
  (decision-trees/load-from-bytes bytes))

(defmethod load-from-bytes :random-forest
  [bytes]
  (decision-trees/load-from-bytes bytes))

(defmethod train :c4.5
  [algorithm predictor-type training-set hyperparameters]
  (decision-trees/train algorithm predictor-type training-set hyperparameters))

(defmethod train :m5p
  [algorithm predictor-type training-set hyperparameters]
  (decision-trees/train algorithm predictor-type training-set hyperparameters))

(defmethod train :random-forest
  [algorithm predictor-type training-set hyperparameters]
  (decision-trees/train algorithm predictor-type training-set hyperparameters))

(defmethod predict :c4.5
  [_ predictor-type model selected-features _hyperparameters feature-vector]
  (decision-trees/predict predictor-type model selected-features feature-vector))

(defmethod predict :m5p
  [_ predictor-type model selected-features _hyperparameters feature-vector]
  (decision-trees/predict predictor-type model selected-features feature-vector))

(defmethod predict :random-forest
  [_ predictor-type model selected-features _hyperparameters feature-vector]
  (decision-trees/predict predictor-type model selected-features feature-vector))
#+END_SRC

** SVM

#+BEGIN_SRC clojure
(defmethod save :svm
  [_ model filepath]
  (svm/save model filepath))

(defmethod load :svm
  [_ filepath]
  (svm/load filepath))

(defmethod train :svm
  [_ _predictor-type training-set-path hyperparameters]
  (svm/train training-set-path hyperparameters))

(defmethod predict :svm
  [_ _predictor-type model seleted-features hyperparameters feature-vector]
  (svm/predict model seleted-features hyperparameters feature-vector))
#+END_SRC

** Linear SVM

#+BEGIN_SRC clojure
(defmethod save :lsvm
  [_ model filepath]
  (linear-svm/save model filepath))

(defmethod load :lsvm
  [_ filepath]
  (linear-svm/load filepath))

(defmethod load-from-bytes :lsvm
  [_ bytes]
  (linear-svm/load bytes))

(defmethod train :lsvm
  [_ _predictor-type training-set-csv-path hyperparameters]
  (linear-svm/train training-set-csv-path hyperparameters))

(defmethod predict :lsvm
  [_ _predictor-type model _selected-features _hyperparameters feature-vector]
  (linear-svm/predict model feature-vector))
#+END_SRC

* Inference

#+BEGIN_SRC clojure
(defn- parse-feature-map
  [selected-features feature-map]
  (reduce-kv #(assoc % %2 (parsing/parse-double %3))
             {}
             (select-keys feature-map selected-features)))

(defn- feature-scaling
  [feature-scaling-fns scaling-factors feature-map]
  (if feature-scaling-fns
    (scaling/scale-feature-map feature-scaling-fns scaling-factors feature-map)
    feature-map))

(defn- unscale-inference
  [label-scaling-fns scaling-factors prediction]
  (if label-scaling-fns
    (scaling/unscale-inference label-scaling-fns scaling-factors prediction)
    prediction))

(defn infer
  "This function performs the inference steps to perform predictions using a
  single trained model. It includes data preparation and post-processing
  operations required by all models. Such operations include:
  - Feature selection
  - Feature scaling (optional)
  - Querying a model prediction
  - Scaling the output of the model (optional)"
  [algorithm predictor-type model selected-features hyperparameters feature-map
   & {:keys [scaling-factors feature-scaling-fns label-scaling-fns]}]
  (->> feature-map
       (parse-feature-map selected-features)
       (feature-scaling feature-scaling-fns scaling-factors)
       (conversion/feature-map-to-vector selected-features)
       (predict algorithm predictor-type model selected-features hyperparameters)
       (unscale-inference label-scaling-fns scaling-factors)))
#+END_SRC

* Evaluation

#+BEGIN_SRC clojure
(defn- to-temp-csv-path
  [header rows]
  (let [file (doto (File/createTempFile "data_" ".csv")
               (.deleteOnExit))]
    (with-open [w (io/writer file)]
      (csv/write-csv w (concat [header] rows)))
    (.getPath file)))

(defn- classify
  [actual predicted]
  (NominalPrediction. actual (NominalPrediction/makeDistribution predicted 2)))

(defn- evaluate-fold
  [algorithm selected-features hyperparameters feature-scaling-fns label-scaling-fns scaling-factors training-csv-path validation-set eval-atoms predictor-type predictions]
  (let [model (train algorithm predictor-type training-csv-path hyperparameters)]
    (doseq [[target & features] validation-set]
      (let [features-map (into {} (map vector selected-features features))
            predicted-value (infer algorithm predictor-type model selected-features hyperparameters features-map
                                   :scaling-factors scaling-factors
                                   :feature-scaling-fns feature-scaling-fns
                                   :label-scaling-fns label-scaling-fns )]
        (when (= predictor-type :classification)
          (.add predictions (classify (Double/parseDouble target) predicted-value)))
        (let [diff (- (parsing/parse-double target) predicted-value)
              abs-error (Math/abs diff)
              square-error (* diff diff)]
          (swap! (:abs-error eval-atoms) #(+ abs-error %))
          (swap! (:square-error eval-atoms) #(+ square-error %))
          (swap! (:n eval-atoms) inc))))
    (dispose algorithm model)))

(defn- cross-validate
  "Evaluate the performance of a model using k-fold cross-validation. Takes a
  training set CSV file as input and the number of `k-folds` to use for the
  cross validation. If `multithreads` is `true`, then each fold will be
  processed on its own thread in parallel."
  [algorithm predictor-type selected-features hyperparameters training-set-path
   & {:keys [k-folds multithreads scaling-factors feature-scaling-fns label-scaling-fns]}]
  {:pre [(some #{:classification :regression} #{predictor-type})]}
  (let [k-folds (or k-folds 10)
        multithreads (or multithreads false)
        [header & training-set] (with-open [in-file (io/reader training-set-path)]
                                   (doall
                                    (csv/read-csv in-file)))
        folds (partition-all (/ (count training-set) k-folds) (shuffle training-set))
        eval-atoms {:n (atom 0)
                    :abs-error (atom 0)
                    :square-error (atom 0)}
        predictions (ArrayList.)
        futures (atom [])]

    (loop [processed-folds 1
           validation-set (first folds)
           training-set-folds (rest folds)]
      (let [training-csv-path (to-temp-csv-path header (apply concat training-set-folds))]
        (when (<= processed-folds k-folds)
          (if multithreads
            (swap! futures conj (future (evaluate-fold algorithm
                                                       selected-features
                                                       hyperparameters
                                                       feature-scaling-fns
                                                       label-scaling-fns
                                                       scaling-factors
                                                       training-csv-path
                                                       validation-set
                                                       eval-atoms
                                                       predictor-type
                                                       predictions)))
            (evaluate-fold algorithm
                           selected-features
                           hyperparameters
                           feature-scaling-fns
                           label-scaling-fns
                           scaling-factors
                           training-csv-path
                           validation-set
                           eval-atoms
                           predictor-type
                           predictions))
          (recur (inc processed-folds)
                 (first training-set-folds)
                 (conj (rest training-set-folds) validation-set)))))
    (when multithreads
      (doseq [f @futures]
        @f))

    (metrics/model-metrics predictor-type predictions eval-atoms)))

(defn evaluate
  "Only cross-validate method is supported at the moment."
  [algorithm predictor-type selected-features hyperparameters training-set-path
   & {:keys [_k-folds _multithreads _scaling-factors _feature-scaling-fns _label-scaling-fns] :as options}]
  (cross-validate algorithm predictor-type selected-features hyperparameters training-set-path hyperparameters options))
#+END_SRC

* Hyperparameters optimization

We generate the various combinations of the hyperparameters to be tried in order to get the best hyperparameters. Each combination is used to train a model with the sampled data and then the best parameters are selected.

The supported hyperparameter search functions are the follwing:
1. Grid Search: we exhaustively try each and every combination possible from the given search space. Note that for continuous values, it is still required to specify a finite list of values to try.

#+BEGIN_SRC clojure
(def supported-hyperparameter-search-fns #{:grid :random})

(s/def :hyperparameter-search-fn/type (s/with-gen supported-hyperparameter-search-fns
                                                  #(s/gen supported-hyperparameter-search-fns)))

(s/def ::hyperparameter-search-fn-common
  (s/keys :req-un [:hyperparameter-search-fn/type]))

(defmulti hyperparameter-search-fn :type)

(defmethod hyperparameter-search-fn :grid [_]
  ::hyperparameter-search-fn-common)

(s/def ::random-iterations int?)

(defmethod hyperparameter-search-fn :random [_]
  (s/merge
    ::hyperparameter-search-fn-common
    (s/keys :req-un [::random-iterations])))

(s/def ::hyperparameter-search-fn (s/multi-spec hyperparameter-search-fn :type))

(def supported-random-search-data-types #{"integer" "decimal" "string"})

(s/def :random-search-data/type (s/with-gen supported-random-search-data-types
                                                  #(s/gen supported-random-search-data-types)))

(s/def ::random-search-data-common
  (s/keys :req-un [:random-search-data/type]))

(s/def ::values (s/coll-of string?))

(s/def ::random-search-data-string (s/keys :req-un [::values]))

(s/def ::random-search-data-decimal (fn [map]
                                      (and (< (:min map) (:max map))
                                           (contains? map :min)
                                           (contains? map :max)
                                           (float? (:min map))
                                           (float? (:max map)))))

(s/def ::random-search-data-integer (fn [map]
                                        (and (< (:min map) (:max map))
                                             (contains? map :min)
                                             (contains? map :max)
                                             (integer? (:min map))
                                             (integer? (:max map)))))

(defmulti random-search-data-spec :type)

(defmethod random-search-data-spec "integer" [_]
  (s/merge
    ::random-search-data-integer
    ::random-search-data-common))

(defmethod random-search-data-spec "decimal" [_]
  (s/merge
    ::random-search-data-decimal
    ::random-search-data-common))

(defmethod random-search-data-spec "string" [_]
  (s/merge
    ::random-search-data-string
    ::random-search-data-common))

(s/def ::random-search-data-spec (s/multi-spec random-search-data-spec :type))

(s/def ::hyp-key-check keyword?)

(s/def ::hyperparameter-search-space-random
    (s/map-of keyowrd? ::random-search-data-spec))

(s/def ::hyperparameter-search-space-grid (s/map-of keyword?
                                               (s/coll-of (s/or :double (s/double-in :infinite? false :NaN? false)
                                                                :integer integer?
                                                                :string string?))))

;; Algorithm specific hyperparameters

(s/def ::hyperparameters (s/or :lsvm ::linear-svm/hyperparameters
                               :svm ::svm/hyperparameters
                               :c45 ::decision-trees/c45-hyperparameters
                               :m5p ::decision-trees/m5p-hyperparameters
                               :rf ::decision-trees/rf-hyperparameters
                               :xgboost ::xgboost/hyperparameters))

(defn- grid-search-combos
  "Given the hyperparameter search space, returns all possible combinations of
  parameters."
  [hyperparameter-search-space]
  (->> (vals hyperparameter-search-space)
       (apply combinatorics/cartesian-product)
       (map #(into {} (map (fn [x y] [x y])
                           (keys hyperparameter-search-space)
                           %)))))

(defn- random-value
  "Generate random values for the given set of parameter constraints which are
   used for random search"
  [{:keys [min max type values]}]
    (case type
      "integer" (+ (rand-int (- max min)) min)
      "decimal" (+ (rand (- max min)) min)
      "string" (rand-nth values)))

(defn random-search-combos
  "Given the hyperparameter search space, generate a given number of random
  combinations of parameters"
  [random-iterations hyperparameter-search-space]
  (repeatedly random-iterations
              #(into {} (map (fn [[key value]] [key (random-value value)])
              hyperparameter-search-space))))


;; TODO: spec hyperparam-search-space
(defn optimize-hyperparameters
  "This function is responsible for training a model with the best
  hyperparameters found by the provided `hyperparameter-search-fn`."
  [algorithm predictor-type selected-features hyperparameters hyperparameter-search-fn hyperparameter-search-space training-set-path
   & {:keys [selection-metric k-folds threads-pool scaling-factors feature-scaling-fns label-scaling-fns]}]
  {:pre [(spec/check ::algorithm algorithm)
         (spec/check ::predictor-type predictor-type)
         (spec/check ::hyperparameters hyperparameters)
         (spec/check (s/nilable ::hyperparameter-search-fn) hyperparameter-search-fn)
         (case (:type hyperparameter-search-fn)
                             :random (spec/check ::hyperparameter-search-space-random hyperparameter-search-space)
                             :grid (spec/check ::hyperparameter-search-space-grid hyperparameter-search-space))]}
  (let [hyperparameter-search-fn (or hyperparameter-search-fn {:type :grid})
        selection-metric (or selection-metric :roc-auc)
        k-folds (or k-folds 2)
        thread-count (or threads-pool 1)
        random-iterations (:random-iterations hyperparameter-search-fn)
        combos (case (:type hyperparameter-search-fn)
                 :grid (grid-search-combos hyperparameter-search-space)
                 :random (random-search-combos random-iterations hyperparameter-search-space))
        eval (fn [hyperparameters-to-optimize]
               (let [result (evaluate algorithm
                                      predictor-type
                                      selected-features
                                      (merge hyperparameters hyperparameters-to-optimize)
                                      training-set-path
                                      :scaling-factors scaling-factors
                                      :k-folds k-folds
                                      :feature-scaling-fns feature-scaling-fns
                                      :label-scaling-fns label-scaling-fns)]
                 {:optimal-params hyperparameters-to-optimize
                  :selected-evaluation (get result selection-metric)
                  :model-evaluations result}))
        find-best (if (= (metrics/comparator selection-metric) <)
                    min-key
                    max-key)
        evaluated-combos (cp/with-shutdown! [pool thread-count]
                           (->> combos
                                (cp/pmap pool eval)
                                (doall)))
        best-evaluation (apply find-best :selected-evaluation evaluated-combos)]
    best-evaluation))
#+END_SRC
