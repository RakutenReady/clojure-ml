#+PROPERTY: header-args:clojure :tangle ../../../../src/curbside/ml/model.clj :mkdirp yes :noweb yes :padline yes :results silent :comments link
#+OPTIONS: toc:2

#+TITLE: ML Algorithms Interface

* Table of Contents                                            :toc:noexport:
- [[#namespace-definition][Namespace definition]]
- [[#multimethods][Multimethods]]
- [[#inference][Inference]]
- [[#evaluation][Evaluation]]
- [[#hyperparameters-optimization][Hyperparameters optimization]]

* Namespace definition

#+BEGIN_SRC clojure
(ns curbside.ml.model
  (:refer-clojure :exclude [load])
  (:require
   [clojure.data.csv :as csv]
   [clojure.java.io :as io]
   [clojure.math.combinatorics :as combinatorics]
   [com.climate.claypoole :as cp]
   [curbside.ml.metrics :as metrics]
   [curbside.ml.utils.parsing :as parsing]
   [curbside.ml.training-sets.scaling :as scaling]
   [curbside.ml.training-sets.conversion :as conversion])
  (:import
   (java.util ArrayList)
   (weka.classifiers.evaluation NominalPrediction)))
#+END_SRC

* Multimethods

All models implement a few common functions:

1. =save= to persist a trained model to disk.
2. =load= to load a trained model from disk.
3. =train= to train the model on a given problem.
4. =predict= to make a prediction
5. =dispose= to free allocated memory, if applicable

We will define multimethods for all of these operations. These multimethods will switch based on a keyword specifying the algorithm to use. Using a keyword allows us to easily specify the algorithm in the pipeline configs.

#+BEGIN_SRC clojure
(defmulti save
  (fn [algorithm model filepath]
    algorithm))

(defmulti load
  (fn [algorithm filepath]
    algorithm))

(defmulti load-from-bytes
  (fn [algorithm bytes]
    algorithm))

(defmulti train
  (fn [algorithm training-set hyperparameters]
    algorithm))

(defmulti predict
  "Not meant to be called directly. Use =infer= instead."
  (fn [algorithm model selected-features hyperparameters feature-vector]
    algorithm))

(defmulti dispose
  (fn [algorithm model]
    algorithm))

(defmethod dispose :default
  [_ _]
  nil)
#+END_SRC

* Inference

#+BEGIN_SRC clojure
(defn- parse-feature-map
  [selected-features feature-map]
  (reduce-kv #(assoc % %2 (parsing/parse-double %3))
             {}
             (select-keys feature-map selected-features)))

(defn- feature-scaling
  [feature-scaling-fns scaling-factors feature-map]
  (if feature-scaling-fns
    (scaling/scale-feature-map feature-scaling-fns scaling-factors feature-map)
    feature-map))

(defn- unscale-inference
  [label-scaling-fns scaling-factors prediction]
  (if label-scaling-fns
    (scaling/unscale-inference label-scaling-fns scaling-factors prediction)
    prediction))

(defn infer
  "This function performs the inference steps to perform predictions using a
  single trained model. It includes data preparation and post-processing
  operations required by all models. Such operations include:
  - Feature selection
  - Feature scaling (optional)
  - Querying a model prediction
  - Scaling the output of the model (optional)"
  [algorithm model selected-features hyperparameters feature-map
   & {:keys [scaling-factors feature-scaling-fns label-scaling-fns]}]
  (->> feature-map
       (parse-feature-map selected-features)
       (feature-scaling feature-scaling-fns scaling-factors)
       (conversion/feature-map-to-vector selected-features)
       (predict algorithm model selected-features hyperparameters)
       (unscale-inference label-scaling-fns scaling-factors)))
#+END_SRC

* Evaluation

#+BEGIN_SRC clojure
(defn- classify
  [actual predicted]
  (NominalPrediction. actual (NominalPrediction/makeDistribution predicted 2)))

(defn- evaluate-fold
  [algorithm selected-features hyperparameters feature-scaling-fns label-scaling-fns scaling-factors training-set validation-set eval-atoms predictor-type predictions]
  (let [training-set (apply concat training-set)
        model (train algorithm training-set hyperparameters)]
    (doseq [[target & features] validation-set]
      (let [features-map (into {} (map vector selected-features features))
            predicted-value (infer algorithm model selected-features hyperparameters feature-scaling-fns label-scaling-fns scaling-factors features-map)]
        (when (= predictor-type :classification)
          (.add predictions (classify (Double/parseDouble target) predicted-value)))
        (let [diff (- (parsing/parse-double target) predicted-value)
              abs-error (Math/abs diff)
              square-error (* diff diff)]
          (swap! (:abs-error eval-atoms) #(+ abs-error %))
          (swap! (:square-error eval-atoms) #(+ square-error %))
          (swap! (:n eval-atoms) inc))))
    (dispose algorithm model)))

(defn- cross-validate
  "Evaluate the performance of a model using k-fold cross-validation. Takes a
  training set CSV file as input and the number of `k-folds` to use for the
  cross validation. If `multithreads` is `true`, then each fold will be
  processed on its own thread in parallel."
  [algorithm predictor-type selected-features hyperparameters training-set-file
   & {:keys [k-folds multithreads scaling-factors feature-scaling-fns label-scaling-fns]}]
  {:pre [(some #{:classification :regression} #{predictor-type})]}
  (let [k-folds (or k-folds 10)
        mode (or predictor-type :classification)
        multithreads (or multithreads false)
        [_headers & training-set] (with-open [in-file (io/reader training-set-file)]
                                    (doall
                                     (csv/read-csv in-file)))
        folds (partition-all (/ (count training-set) k-folds) (shuffle training-set))
        eval-atoms {:n (atom 0)
                    :abs-error (atom 0)
                    :square-error (atom 0)}
        predictions (ArrayList.)
        futures (atom [])]

    (loop [processed-folds 1
           validation-set (first folds)
           training-set-folds (rest folds)]
      (when (<= processed-folds k-folds)
        (if multithreads
          (swap! futures conj (future (evaluate-fold algorithm
                                                     selected-features
                                                     hyperparameters
                                                     feature-scaling-fns
                                                     label-scaling-fns
                                                     scaling-factors
                                                     training-set-folds
                                                     validation-set
                                                     eval-atoms
                                                     mode
                                                     predictions)))
          (evaluate-fold algorithm
                         selected-features
                         hyperparameters
                         feature-scaling-fns
                         label-scaling-fns
                         scaling-factors
                         training-set-folds
                         validation-set
                         eval-atoms
                         mode
                         predictions))
        (recur (inc processed-folds)
               (first training-set-folds)
               (conj (rest training-set-folds) validation-set))))

    (when multithreads
      (doseq [f @futures]
        @f))

    (metrics/model-metrics mode predictions eval-atoms)))

(defn evaluate
  "Only cross-validate method is supported at the moment."
  [algorithm predictor-type selected-features hyperparameters training-set-file
   & {:keys [_k-folds _multithreads _scaling-factors _feature-scaling-fns _label-scaling-fns] :as options}]
  (cross-validate algorithm predictor-type selected-features hyperparameters training-set-file hyperparameters options))
#+END_SRC

* Hyperparameters optimization

#+BEGIN_SRC clojure
(defn- grid-search
  [algorithm predictor-type selected-features grid-parameters training-set-file
   & {:keys [selection-metric k-folds threads-pool scaling-factors feature-scaling-fns label-scaling-fns]}]
  (let [selection-metric (or selection-metric :roc-auc)
        k-folds (or k-folds 2)
        thread-count (or threads-pool 1)
        params-keys (keys grid-parameters)
        combos (->> (apply combinatorics/cartesian-product (vals grid-parameters))
                    (map #(into {} (map (fn [x y] [x y])
                                        params-keys
                                        %))))
        eval (fn [hyperparameters]
               (let [result (evaluate algorithm
                                      predictor-type
                                      selected-features
                                      hyperparameters
                                      training-set-file
                                      :scaling-factors scaling-factors
                                      :k-folds k-folds
                                      :feature-scaling-fns feature-scaling-fns
                                      :label-scaling-fns label-scaling-fns)]
                 {:optimal-params hyperparameters
                  :selected-evaluation (get result selection-metric)
                  :model-evaluations result}))
        find-best (if (= (metrics/comparator selection-metric) <)
                    min-key
                    max-key)
        evaluated-combos (cp/with-shutdown! [pool thread-count]
                           (->> combos
                                (cp/pmap pool eval)
                                (doall)))
        best-evaluation (apply find-best :selected-evaluation evaluated-combos)]
    best-evaluation))

(defn optimize-hyperparameters
  [algorithm predictor-type selected-features grid-parameters training-set-file
   & {:keys [selection-metric k-folds threads-pool scaling-factors feature-scaling-fns label-scaling-fns]}]
  (grid-search algorithm predictor-type selected-features grid-parameters training-set-file
               :selection-metric selection-metric
               :k-folds k-folds
               :threads-pool threads-pool
               :scaling-factors scaling-factors
               :feature-scaling-fns feature-scaling-fns
               :label-scaling-fns label-scaling-fns))
#+END_SRC
